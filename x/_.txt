#[inline(always)]
fn xfov(hfov: f64, x: f64, y: f64) -> f64 {
  (2. * ((hfov.to_radians() / 2.).tan() * (y / x)).atan()).to_degrees()
}

#[inline(always)]
fn stim(n1: i32, n2: i32) -> (i32, i32) {
  let next = step(n1, n2);

  match next.cmp(&0) {
    Greater => (n1, next),
    Less => (-n1, next),
    Equal => (n2, next),
  }
}

#[inline(always)]
fn step(n1: i32, n2: i32) -> i32 {
  match n2.cmp(&0) {
    Greater => (n2 - n1).max(0),
    Less => (n2 + n1).min(0),
    Equal => 0,
  }
}

cmp::Ordering::{
  Equal,
  Greater,
  Less,
},
